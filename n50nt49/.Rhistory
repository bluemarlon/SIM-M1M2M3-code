ts7 <- gents4(len=1e3, seg=5)
all.series <- rbind(ts1, ts2, ts6, ts3, ts4, ts7)
ts6 <- gar1(len = 1e3+1, phi=1.2)
gents4 <- function(len=1e3, seg = 5){
c(replicate(n = seg, c(arima.sim(n=floor(len/(seg*2)), model = list(ar=0.7)),
gar1(len=floor(len/(seg*2))+1, phi = 1.3))))
}
ts7 <- gents4(len=1e3, seg=5)
set.seed(1)
ts1 <- arima.sim(n=1e3, model = list(ar=0.7))
ts2 <- arima.sim(n=1e3, model = list(ar=-0.7))
gents2 <- function(len=1e3, seg = 5){
c(replicate(n = seg, c(arima.sim(n=floor(len/(seg*2)), model = list(ar=0.7)),
arima.sim(n=floor(len/(seg*2)), model = list(ar=-0.7)))))
}
ts3 <- gents2()
gents3 <- function(len=1e3, seg = 5){
c(replicate(n = seg, c(arima.sim(n=floor(len), model = list(ar=0.7)),
arima.sim(n=floor(len), model = list(ar=-0.7)))))
}
ts4 <- gents3(len=5e2, seg=1)
gar1 <- function(len = 1e3, phi){
nwhite <- rnorm(n=len)
return((nwhite + lag(nwhite, 1) * phi)[-1])
}
ts6 <- gar1(len = 1e3+1, phi=1.2)
gents4 <- function(len=1e3, seg = 5){
c(replicate(n = seg, c(arima.sim(n=floor(len/(seg*2)), model = list(ar=0.7)),
gar1(len=floor(len/(seg*2))+1, phi = 1.3))))
}
ts7 <- gents4(len=1e3, seg=5)
ts5 <- gents3(len=5e2, seg=4)
all.series <- rbind(ts1, ts2, ts6, ts3, ts4, ts7)
all.series.use <- nrow(all.series)
d.use <- cbind(sub=1:all.series.use, all.series) %>% tbl_df%>%
gather( key="month", value=v, -sub, na.rm=TRUE)
d.use$month  <- as.numeric(unlist(strsplit(d.use$month, "V")))[2*1:nrow(d.use)]
d.use <- d.use %>%  arrange(sub, month)
g <- ggplot(data=d.use, aes(x=month, y=v, group = sub))
g + geom_line() + facet_wrap(~sub)+ xlab("Time series length") + ylab("values")
mk.net <- function(dat,
method = "DTW",
sep.piece = 50,
spc.kernel = kernel("modified.daniell", c(1))
){
# dat should be a vector;
# use method to make the network
# separate pieces, the length of each piece should be valid for the method
# separate pieces as size of the network
# return lower trianguler matrix as the distance matrix
# if second order spectrum, option to scpecify kernel
sep.len <- floor(length(dat)/sep.piece)
pair.dist <- matrix(0, sep.piece, sep.piece)
if(method == "DTW"){
for(k1 in 1:(sep.piece-1)){
for(k2 in (k1+1):sep.piece){
if(k2 == sep.piece)
pair.dist[k2, k1] <- diss.DTWARP(dat[1:sep.len + (k1-1)*sep.len],
dat[-(1:((k2-1)*sep.len))])
pair.dist[k2, k1] <- diss.DTWARP(dat[1:sep.len + (k1-1)*sep.len],
dat[1:sep.len + (k2-1)*sep.len])
}
}
}
if(method == "EUCL"){
for(k1 in 1:(sep.piece-1)){
for(k2 in (k1+1):sep.piece){
if(k2 == sep.piece)
pair.dist[k2, k1] <- diss.EUCL(dat[1:sep.len + (k1-1)*sep.len],
dat[-(1:((k2-1)*sep.len))])
pair.dist[k2, k1] <- diss.EUCL(dat[1:sep.len + (k1-1)*sep.len],
dat[1:sep.len + (k2-1)*sep.len])
}
}
}
if(method == "DWT"){
for(k1 in 1:(sep.piece-1)){
for(k2 in (k1+1):sep.piece){
if(k2 == sep.piece)
pair.dist[k2, k1] <- diss(list(dat[1:sep.len + (k1-1)*sep.len],
dat[-(1:((k2-1)*sep.len))]), METHOD = "DWT")
pair.dist[k2, k1] <- diss(list(dat[1:sep.len + (k1-1)*sep.len],
dat[1:sep.len + (k2-1)*sep.len]), METHOD = "DWT")# DTWARP
}
}
}
if(method == "AR3"){
ar3 <- c()
for(kk in 1:sep.piece){
if(sep.piece==kk){
ar3 <- cbind(ar3,
arima(dat[-(1:((kk-1)*sep.len))],
order = c(3,0,0))$coef
)
}else{
ar3 <- cbind(ar3,
arima(dat[1:sep.len + (kk-1)*sep.len],
order = c(3,0,0))$coef)
}
}
# print(ar3)
for(k1 in 1:(sep.piece-1)){
for(k2 in (k1+1):sep.piece){
pair.dist[k2, k1] <- mean(abs(ar3[, k1] - ar3[, k2]))
}
}
}
if(method == "spectrum"){
spc <- c()
for(kk in 1:sep.piece){
if(sep.piece==kk){
spc <- cbind(spc,
spec.pgram(dat[-(1:((kk-1)*sep.len))],
kernel = spc.kernel,
plot = F)$spec)
}else{
spc <- cbind(spc,
spec.pgram(dat[1:sep.len + (kk-1)*sep.len],
kernel = spc.kernel,
plot = F)$spec)
}
}
for(k1 in 1:(sep.piece-1)){
for(k2 in (k1+1):sep.piece){
pair.dist[k2, k1] <- diss.EUCL(spc[, k1], spc[, k2])
}
}
}
if(method == "takens"){
taken.diag <- list()
for(kk in 1:sep.piece){
if(kk == sep.piece)
takens=cbind(dat[1:sep.len + (kk-1)*sep.len], lag(dat[1:sep.len + (kk-1)*sep.len], 1))[-1,]
takens=cbind(dat[1:sep.len + (kk-1)*sep.len], lag(dat[1:sep.len + (kk-1)*sep.len], 1))[-1,]
taken.diag <- c(taken.diag, list(ripsDiag(X=takens, maxdimension = 1,
maxscale = max(dat), library = "Dionysus")$diagram))
}
for(k1 in 1:(sep.piece-1)){
for(k2 in (k1+1):sep.piece){
pair.dist[k2, k1] <- bottleneck(taken.diag[[k1]],
taken.diag[[k2]])
}
}
}
return(pair.dist)
}
################################1.1 EUCL network################################################
sep.piece = 10
dist.EUCL <- list()
for(k in 1:all.series.use){
dist.EUCL <- c(dist.EUCL, list(mk.net(dat = all.series[k, ], method = "EUCL", sep.piece = sep.piece)))
}
dist.EUCL <- c(dist.EUCL, list(mk.net(dat = ts5, sep.piece = sep.piece)))
#make a manifold
par(mfrow = c(3,3))
for(k in 1:length(dist.DTW)){
d <- as.dist(dist.EUCL[[k]]) # euclidean distances between the rows
fit <- cmdscale(d,eig=TRUE, k=2) # k is the number of dim
x <- fit$points[,1]
y <- fit$points[,2]
plot(x, y, xlab="Coordinate 1", ylab="Coordinate 2",
#xlim=c(-100, 70), ylim=c(-80, 80),
main="Metric MDS", type="n")
text(x, y, labels = 1:10, cex=.7)
# fit <- smacofSym(d)
# plot(fit)
}
title(main = "EUCL")
################################1.1 DTW network################################################
sep.piece = 10
dist.DTW <- list()
for(k in 1:all.series.use){
dist.DTW <- c(dist.DTW, list(mk.net(dat = all.series[k, ], sep.piece = sep.piece)))
}
dist.DTW <- c(dist.DTW, list(mk.net(dat = ts5, sep.piece = sep.piece)))
#make a manifold
par(mfrow = c(3,3))
for(k in 1:length(dist.DTW)){
d <- as.dist(dist.DTW[[k]]) # euclidean distances between the rows
fit <- cmdscale(d,eig=TRUE, k=2) # k is the number of dim
x <- fit$points[,1]
y <- fit$points[,2]
plot(x, y, xlab="Coordinate 1", ylab="Coordinate 2",
# xlim=c(-100, 70), ylim=c(-80, 80),
main="Metric MDS", type="n")
text(x, y, labels = 1:10, cex=.7)
# fit <- smacofSym(d)
# plot(fit)
}
title(main = "DTW")
sep.piece = 10
dist.EUCL <- list()
for(k in 1:all.series.use){
dist.EUCL <- c(dist.EUCL, list(mk.net(dat = all.series[k, ], method = "EUCL", sep.piece = sep.piece)))
}
dist.EUCL <- c(dist.EUCL, list(mk.net(dat = ts5, method = "EUCL", sep.piece = sep.piece)))
par(mfrow = c(3,3))
for(k in 1:length(dist.EUCL)){
d <- as.dist(dist.EUCL[[k]]) # euclidean distances between the rows
fit <- cmdscale(d,eig=TRUE, k=2) # k is the number of dim
x <- fit$points[,1]
y <- fit$points[,2]
plot(x, y, xlab="Coordinate 1", ylab="Coordinate 2",
#xlim=c(-100, 70), ylim=c(-80, 80),
main="Metric MDS", type="n")
text(x, y, labels = 1:10, cex=.7)
# fit <- smacofSym(d)
# plot(fit)
}
title(main = "EUCL")
?title
mtext(main = "EUCL")
mtext(text = "EUCL")
sep.piece = 10
dist.DTW <- list()
for(k in 1:all.series.use){
dist.DTW <- c(dist.DTW, list(mk.net(dat = all.series[k, ], sep.piece = sep.piece)))
}
dist.DTW <- c(dist.DTW, list(mk.net(dat = ts5, sep.piece = sep.piece)))
par(mfrow = c(3,3))
for(k in 1:length(dist.DTW)){
d <- as.dist(dist.DTW[[k]]) # euclidean distances between the rows
fit <- cmdscale(d,eig=TRUE, k=2) # k is the number of dim
x <- fit$points[,1]
y <- fit$points[,2]
plot(x, y, xlab="Coordinate 1", ylab="Coordinate 2",
# xlim=c(-100, 70), ylim=c(-80, 80),
main="Metric MDS", type="n")
text(x, y, labels = 1:10, cex=.7)
# fit <- smacofSym(d)
# plot(fit)
}
mtext(text = "DTW")
sep.piece = 10
dist.DTW <- list()
for(k in 1:all.series.use){
dist.DTW <- c(dist.DTW, list(mk.net(dat = all.series[k, ], sep.piece = sep.piece)))
}
dist.DTW <- c(dist.DTW, list(mk.net(dat = ts5, sep.piece = sep.piece*2)))
par(mfrow = c(3,3))
for(k in 1:length(dist.DTW)){
d <- as.dist(dist.DTW[[k]]) # euclidean distances between the rows
fit <- cmdscale(d,eig=TRUE, k=2) # k is the number of dim
x <- fit$points[,1]
y <- fit$points[,2]
plot(x, y, xlab="Coordinate 1", ylab="Coordinate 2",
# xlim=c(-100, 70), ylim=c(-80, 80),
main="Metric MDS", type="n")
text(x, y, labels = 1:10, cex=.7)
# fit <- smacofSym(d)
# plot(fit)
}
mtext(text = "DTW")
##############make simulations#############
# AR(1) 0.7, AR(1) -0.7
set.seed(1)
ts1 <- arima.sim(n=1e3, model = list(ar=0.7))
ts2 <- arima.sim(n=1e3, model = list(ar=-0.7))
gents2 <- function(len=1e3, seg = 5){
c(replicate(n = seg, c(arima.sim(n=floor(len/(seg*2)), model = list(ar=0.7)),
arima.sim(n=floor(len/(seg*2)), model = list(ar=-0.7)))))
}
ts6 <- gar1(len = 1e3+1, phi=1.2)
ts3 <- gents2()
gents3 <- function(len=1e3, seg = 5){
c(replicate(n = seg, c(arima.sim(n=floor(len), model = list(ar=0.7)),
arima.sim(n=floor(len), model = list(ar=-0.7)))))
}
ts4 <- gents3(len=5e2, seg=1)
gar1 <- function(len = 1e3, phi){
nwhite <- rnorm(n=len)
return((nwhite + lag(nwhite, 1) * phi)[-1])
}
gents4 <- function(len=1e3, seg = 5){
c(replicate(n = seg, c(arima.sim(n=floor(len/(seg*2)), model = list(ar=0.7)),
gar1(len=floor(len/(seg*2))+1, phi = 1.3))))
}
ts7 <- gents4(len=1e3, seg=5)
ts5 <- gents3(len=5e2, seg=5)
all.series <- rbind(ts1, ts2, ts6, ts3, ts4, ts7)
all.series.use <- nrow(all.series)
d.use <- cbind(sub=1:all.series.use, all.series) %>% tbl_df%>%
gather( key="month", value=v, -sub, na.rm=TRUE)
d.use$month  <- as.numeric(unlist(strsplit(d.use$month, "V")))[2*1:nrow(d.use)]
d.use <- d.use %>%  arrange(sub, month)
g <- ggplot(data=d.use, aes(x=month, y=v, group = sub))
g + geom_line() + facet_wrap(~sub)+ xlab("Time series length") + ylab("values")
par(mfrow = c(1,1))
ts.plot(ts5)
################################1.1 EUCL network################################################
sep.piece = 10
dist.EUCL <- list()
for(k in 1:all.series.use){
dist.EUCL <- c(dist.EUCL, list(mk.net(dat = all.series[k, ], method = "EUCL", sep.piece = sep.piece)))
}
dist.EUCL <- c(dist.EUCL, list(mk.net(dat = ts5, method = "EUCL", sep.piece = sep.piece)))
#make a manifold
par(mfrow = c(3,3))
for(k in 1:length(dist.EUCL)){
d <- as.dist(dist.EUCL[[k]]) # euclidean distances between the rows
fit <- cmdscale(d,eig=TRUE, k=2) # k is the number of dim
x <- fit$points[,1]
y <- fit$points[,2]
plot(x, y, xlab="Coordinate 1", ylab="Coordinate 2",
#xlim=c(-100, 70), ylim=c(-80, 80),
main="Metric MDS", type="n")
text(x, y, labels = 1:10, cex=.7)
# fit <- smacofSym(d)
# plot(fit)
}
mtext(text = "EUCL")
################################1.1 DTW network################################################
sep.piece = 10
dist.DTW <- list()
for(k in 1:all.series.use){
dist.DTW <- c(dist.DTW, list(mk.net(dat = all.series[k, ], sep.piece = sep.piece)))
}
dist.DTW <- c(dist.DTW, list(mk.net(dat = ts5, sep.piece = sep.piece)))
#make a manifold
par(mfrow = c(3,3))
for(k in 1:length(dist.DTW)){
d <- as.dist(dist.DTW[[k]]) # euclidean distances between the rows
fit <- cmdscale(d,eig=TRUE, k=2) # k is the number of dim
x <- fit$points[,1]
y <- fit$points[,2]
plot(x, y, xlab="Coordinate 1", ylab="Coordinate 2",
# xlim=c(-100, 70), ylim=c(-80, 80),
main="Metric MDS", type="n")
text(x, y, labels = 1:10, cex=.7)
# fit <- smacofSym(d)
# plot(fit)
}
mtext(text = "DTW")
setwd("~/Dropbox/Topological Data Analysis/classification")
takens.d <- function(){
sep.piece = 10
dist.takens <- list()
for(k in 1:all.series.use){
dist.takens <- c(dist.takens,
list(mk.net(dat = all.series[k, ], sep.piece = sep.piece, method = "takens")))
}
return(dist.takens)
}
system.time(dist.takens <- takens.d())
# user  system elapsed
# 101.825   1.329 115.558
# way too slow
saveRDS(dist.takens, "takens.rds")
#make a manifold
par(mfrow = c(3,3))
for(k in 1:all.series.use){
d <- as.dist(dist.takens[[k]]) # euclidean distances between the rows
fit <- cmdscale(d,eig=TRUE, k=2) # k is the number of dim
x <- fit$points[,1]
y <- fit$points[,2]
plot(x, y, xlab="Coordinate 1", ylab="Coordinate 2",
#xlim=c(-100, 70), ylim=c(-80, 80),
main="Metric MDS", type="n")
text(x, y, labels = 1:10, cex=.7)
# fit <- smacofSym(d)
# plot(fit)
}
diss.EUCL(ts2,ts3)
diss.DTWARP()
diss.DTWARP(ts2,ts3)
?diss.DTWARP
ts2[1:3]
ts3[1:3]
diss.EUCL(ts2[1:3], ts3[1:3])
diss.DTWARP(ts2[1:3], ts3[1:3])
sum(abs(ts2[1:3]-ts3[1:3]))
diss.DTWARP(abs(ts2[1:3]), abs(ts3[1:3]))
sum(abs(abs(ts2[1:3])-abs(ts3[1:3])))
abs(ts3[1:3])
abs(ts2[1:3])
diss.DTWARP(c(0.2979928, 0.4455755, 1.0274996), c(0.3889262, 1.1422539, 0.8564260))
diss.DTWARP(c(0.2979928, 0.4455755, 1.0274996), c(0.3889262,  0.8564260, 1.1422539))
sum(abs(c(0.2979928, 0.4455755, 1.0274996) - c(0.3889262,  0.8564260, 1.1422539)))
sqrt(sum(c(0.2979928, 0.4455755, 1.0274996) - c(0.3889262,  0.8564260, 1.1422539))^2)
?diss.DTWARP
library(dtw)
?dtw
dtw(c(0.2979928, 0.4455755, 1.0274996), c(0.3889262,  0.8564260, 1.1422539))
dtw(x=c(0.2979928, 0.4455755, 1.0274996), y=c(0.3889262,  0.8564260, 1.1422539))
dtw(x=c(0.2979928, 0.4455755, 1.0274996), y=c(0.3889262,  0.8564260, 1.1422539))$distance
sum(c(0.2979928, 0.4455755, 1.0274996) - c(0.3889262,  0.8564260, 1.1422539))^2
sum((c(0.2979928, 0.4455755, 1.0274996) - c(0.3889262,  0.8564260, 1.1422539))^2)
sqrt(sum((c(0.2979928, 0.4455755, 1.0274996) - c(0.3889262,  0.8564260, 1.1422539))^2))
dtw(x=c(0.2979928, 0.4455755, 1.0274996), y=c(0.3889262,  0.8564260, 1.5422539))$distance
sqrt(sum((c(0.2979928, 0.4455755, 1.0274996) - c(0.3889262,  0.8564260, 1.5422539))^2))
diss.DTWARP(x=c(0.2979928, 0.4455755, 1.0274996), y=c(0.3889262,  0.8564260, 1.5422539))
dtw(x=c(0.2979928, 0.4455755, 1.0274996), y=c(0.3889262,  0.8564260, 1.5422539), dist.method = "Euclidean")$distance
c(0.2979928, 0.4455755, 1.0274996) - c(0.3889262,  0.8564260, 1.5422539)
(c(0.2979928, 0.4455755, 1.0274996) - c(0.3889262,  0.8564260, 1.5422539))^2
sum((c(0.2979928, 0.4455755, 1.0274996) - c(0.3889262,  0.8564260, 1.5422539))^2)
dtw
aa <- dtw(x=c(0.2979928, 0.4455755, 1.0274996), y=c(0.3889262,  0.8564260, 1.5422539), dist.method = "Euclidean")
aa
aa <- dtw(x=c(0.2979928, 0.4455755, 1.0274996), y=c(0.3889262,  0.8564260, 1.5422539), dist.method = "Euclidean", keep.internals = T)
aa
aa$costMatrix
aa$distance
c(0.2979928, 0.4455755, 1.0274996) - c(0.3889262,  0.8564260, 1.5422539)
abs(c(0.2979928, 0.4455755, 1.0274996) - c(0.3889262,  0.8564260, 1.5422539))
sum(abs(c(0.2979928, 0.4455755, 1.0274996) - c(0.3889262,  0.8564260, 1.5422539)))
setwd("~/Dropbox/Renjie Chen/Ofer Harel 2016/Final SIM paper Oct 2018/Code and Results/Simulations SMRMSSM/n50nt49")
library(data.table)
dd <- fread("SSMSSM_1.csv")
dd
k <- 1
sdbias <- c()
rmse <- c()
width <- c()
coverage <- c()
for(k in 1:4){
#################################SM#######################################
dat1 <- read.csv(paste0("SSMSM",k, ".csv", sep = ""))
# dat1 <- read.csv(paste0("RMSM", k, ".csv", sep = ""))
# dat1 <- read.csv(paste0("SMSM", ".csv", sep = ""))
need.list <- c("intbias", "intsd", "x1bias", "x1sd","x2bias", "x2sd", "sig2bias", "sig2sd", "sig0bias", "sig0sd")
bias.list <- c("intbias", "x1bias", "x2bias", "sig2bias", "sig0bias")
biasd.list <- c("intsd", "x1sd", "x2sd", "sig2sd", "sig0sd")
cal1<- dat1[, need.list]
bias1 <- cal1[, bias.list]
biasd1 <- cbind(cal1[, biasd.list])
#################################RM#######################################
dat2 <- read.csv(paste0("SSMRM", k, ".csv", sep = ""))
# dat2 <- read.csv(paste0("RMRM", k, ".csv", sep = ""))
# dat2 <- read.csv(paste0("SMRM", ".csv", sep = ""))
need.list <- c("intbias", "intsd", "x1bias", "x1sd","x2bias", "x2sd", "sig2bias", "sig2sd", "phibias", "resbias", "resd")
bias.list <- c("intbias", "x1bias", "x2bias", "sig2bias", "resbias", "phibias")
biasd.list <- c("intsd", "x1sd", "x2sd", "sig2sd", "resd")
cal2<- dat2[, need.list]
bias2 <- cal2[, bias.list]
biasd2 <- cbind(cal2[, biasd.list],"phisd"=dat2[, "phiwidth"]/(2*1.96))
colnames(biasd2)[ncol(biasd2)] <- "phisd"
#################################SSM#######################################
dat3 <- read.csv(paste0("SSMSSM_", k, ".csv", sep = ""))
# dat3 <- read.csv(paste0("RMSSM_", k, ".csv", sep = ""))
# dat3 <- read.csv(paste0("SMSSM", ".csv", sep = ""))
need.list <- c("intbias", "intsd","x1bias", "x1sd","x2bias", "x2sd", "Vx2bias", "Vx2sd", "phibias", "phisd", "sig0bias", "sig0sd")
bias.list <- c("intbias", "x1bias", "x2bias", "Vx2bias", "sig0bias", "phibias")
biasd.list <- c("intsd", "x1sd", "x2sd", "Vx2sd", "sig0sd", "phisd")
cal3<- dat3[, need.list]
bias3 <- cal3[, bias.list]
biasd3 <- cal3[, biasd.list]
#################################make table#######################################
#################################SM#######################################
#sdbias
sdbias1 <- round(colMeans(bias1/biasd1)*100, digits = 1)
#RMSE
rmse1 <- round(sqrt(colMeans(bias1^2)), digits = 2)
wid.list <- c("intwidth","x1width", "x2width", "sig2width", "sig0width")
coverage.list <- c("intcoverage","x1coverage", "x2coverage", "sig2coverage", "sig0coverage")
#width
width1<- round(colMeans(dat1[, wid.list]), digits = 2)
#coverage
coverage1 <- round(colMeans(dat1[, coverage.list])*100, digits = 1)
#################################RM#######################################
sdbias2 <- round(colMeans(bias2 /biasd2)*100, digits = 1)
#RMSE
print(rmse2 <- round(sqrt(colMeans(bias2^2)), digits = 2))
wid.list <- c( "intwidth","x1width", "x2width", "sig2width", "reswidth", "phiwidth")
coverage.list <- c("intcoverage","x1coverage", "x2coverage", "sig2coverage", "rescoverage", "phicoverage")
#width
print(width2<- round(colMeans(dat2[, wid.list]), digits = 2))
#coverage
print(coverage2 <- round(colMeans(dat2[, coverage.list])*100, digits = 1))
#################################SSM#######################################
#sdbias
print(sdbias3 <- round(colMeans(bias3/biasd3)*100, digits = 1))
#RMSE
print(rmse3 <- round(sqrt(colMeans(bias3^2)), digits = 2))
wid.list <- c("intwidth","x1width", "x2width", "Vx2width", "sig0width", "phiwidth")
coverage.list <- c("intcoverage","x1coverage", "x2coverage", "Vx2coverage", "sig0coverage", "phicoverage")
#width
print(width3<- round(colMeans(dat3[, wid.list]), digits = 2))
#coverage
print(coverage3 <- round(colMeans(dat3[, coverage.list])*100, digits = 1))
#################################combine#######################################
print(sdbias <- cbind(sdbias,cbind(c(sdbias1, NaN), sdbias2, sdbias3)))
print(rmse <- cbind(rmse, cbind(c(rmse1, NaN), rmse2, rmse3)))
print(width <- cbind(width, cbind(c(width1, NaN), width2, width3)))
print(coverage <- cbind(coverage, cbind(c(coverage1, NaN), coverage2, coverage3)))
}
apply(sdbias, 1, FUN = function(x) paste0(x, collapse = "&"))
apply(rmse, 1, FUN = function(x) paste0(x, collapse = "&"))
apply(coverage, 1, FUN = function(x) paste0(x, collapse = "&"))
apply(width, 1, FUN = function(x) paste0(x, collapse = "&"))
get_z_star = function(alpha) {
return(-qnorm(alpha / 2))
}
get_beta = function(z_star, s, d_min, N) {
SE = s /  sqrt(N)
return(pnorm(z_star * SE, mean=d_min, sd=SE))
}
required_size = function(s, d_min, Ns=1:20000, alpha=0.05, beta=0.2) {
for (N in Ns) {
if (get_beta(get_z_star(alpha), s, d_min, N) <= beta) {
return(N)
}
}
return(-1)
}
required_size(s=sqrt(0.1*0.9*2), d_min=0.02)
required_size(s=0.00515*sqrt(5000), d_min=0.02)
required_size(s=0.0119*sqrt(5000), d_min=0.02)
required_size(s=0.0628*sqrt(1000), d_min=0.01, Ns=seq(10, 500000, 100))
required_size(s=0.0209*sqrt(1000), d_min=0.01, Ns=seq(10, 500000, 100))
required_size(s=0.0188*sqrt(1000), d_min=0.015)
required_size(s=0.0445*sqrt(1000), d_min=0.015, Ns=seq(10, 500000, 100))
?qnorm
